---
title: Lines of sight (demo)
categories: games; computer science
---

<!DOCTYPE html>
<div style="display: grid;">
<div id="background-grid-div"><pre><code id="background-grid">
</code></pre></div>
<pre><code id="grid"></code></pre>
</div>
<pre><code id="instructions">
 #      <span class="a">@</span>      O      ?     .

 W      ↑                  
ASD    ←↓→     QE     R     C
</code></pre>

<div id="how">
<h2>How it works</h2>

<p>First, we need to determine the circle of view. A naïve approach would be to take all points a distance of R or less from the origin, where R is the radius of the circle of view. However, this produces poor circles&mdash;in particular, the circle will be &ldquo;pointy&rdquo; in the four cardinal directions. There is a better algorithm for this known as Bresenham&#8217;s circle algorithm, which draws <a href="https://possiblywrong.wordpress.com/2022/02/14/bresenhams-circles-are-always-optimal/" target="_blank" rel="noreferrer">optimal circles</a>:</p>

<pre><code>
def drawCircle(radius):
    x=radius; y=0; error=3-2*radius; points=set()
    while x >= y:
        # Modified to draw filled circles.
        # To draw only the outline, replace the following with the
        # line `points.update(((x,y),(x,-y),(-x,y),(-x,-y),(y,x),(y,-x),(-y,x),(-y,-x)))`.
        for i in range(-x,x+1):
            for j in (y,-y):
                points.add((i,j)); points.add((j,i))

        if error > 0: x -= 1; error -= 4*x
        y += 1; error += 4*y + 2
    return points
</code></pre>

<p>Next, we need to decide how we are going to draw lines. In the continuous 2D case, you can calculate exact field of view using a technique called shadowcasting. In the discrete case, however, there is no objective definition of field of view&mdash;it depends how you decide to model the player, walls and arena. The discrete case also presents various quirks that cause many implementations to violate desirable properties such as symmetry (point A can see point B if and only if B can see A) and contiguousness of field of view (see the &ldquo;No artifacts&rdquo; section in this <a href="https://www.albertford.com/shadowcasting/" target="_blank" rel="noreferrer">lovely article</a> on shadowcasting with bevelled walls for an example of artifacts).</p>
<p>The approach used here is described in this page on <a href="https://www.roguebasin.com/index.php?title=Pre-Computed_Visibility_Tries" target="_blank" rel="noreferrer">Pre-Computed Visibility Tries</a> (though I don&#8217;t really get how the data structure is a trie). This approach has the advantage that all lines drawn are themselves discrete, so no artifacts are created through mapping the discrete to the continuous world.</p>
<p>Though this page used Bresenham&#8217;s circle algorithm for the diagrams, existing implementations use the naïve approach, leading to poor circles. It works as follows: you draw all possible rays from the origin within the view circle using Bresenham&#8217;s (again) line algorithm and pre-calculate a tree of all paths. (Individual points may occur multiple times in the tree on mutually distinct paths.) Then field of view can be calculated with a simple tree search stopping at walls.</p>
<p>There are two modifications I made to the algorithm as described. First, Bresenham&#8217;s line algorithm isn&#8217;t symmetric&mdash;many cases such as</p>

<pre style="text-align: center;"><code>
XX             X  
  X             XX
</code></pre>

<p>are ambiguous and the algorithm need only consistently bias one case. The linked implementation gains symmetry by choosing one bias arbitrarily. I think morally both ought to be considered instead of choosing one arbitrarily, so I rectify this instead by drawing every line with both biases. (With a typical implementation of Bresenham&#8217;s line algorithm, this can be done easily by swapping the start and end point.)</p>
<p>Secondly, drawing a ray to all points within the circle as described does not draw all possible Bresenham rays from the circle&mdash;plenty of angles are missed out. By considering extremely narrow angles it can be shown that some points up to a circle of radius ~2R must be considered, but I couldn&#8217;t work out what bounding shape is needed to draw all possible rays within a circle (or any other algorithm that simply generates them)&mdash;it would be helpful if someone could work this out! I chose a square of side length (4R+1) centred on the origin as I saw no extra lines from larger boxes, but as these trees are pre-calculated anyway, you could use a massive region if you were worried about this&mdash;it makes no difference. You need to modify the algorithm to stop when the line leaves the view circle.</p>
<p>With these amendments, this algorithm defines line of sight as the following: a point A can be seen from the origin if and only if there is a Bresenham ray with either direction bias consisting of points (0,0)=L0,L1,L2,...,L[n-1] such that A = Lk for some 0&lt;=k&lt;n and no points Li for 1&lt;=i&lt;k are walls. I think this definition is the most natural discrete analogue of the continuous case and it also satisfies several ideal properties such as attractive behaviour when close to walls, symmetry, and contiguity of field of view. It is certainly on the permissive side of visibility&mdash;if less is desired, considering only rays to points within the circle is a reasonable trick to cut down on the most unusual angles. (Seeing through diagonally-placed walls may be disconcerting, but I understand that it is a long-standing tradition in the roguelike genre.) The pre-calculated trees for a given radius make its calculation extremely cheap.</p>
</div>

<style>
@font-face {
    font-family: "Fira Mono";
    font-weight: 300;
    src: url("../assets/fonts/fira_mono_regular.woff2");
}

@font-face {
    font-family: "Fira Mono";
    font-weight: 600;
    src: url("../assets/fonts/fira_mono_bold.woff2");
}
body {
    background-color: #222;
    color: #AAA;
    font-family: "Fira Mono";
    width: 100%;
    height: 100%;
}

code { font-family: "Fira Mono"; font-size: 80%; }

#grid, #test-grid { color: #999;/*#3c3c3c*/; z-index: 2; }

#background-grid-div { position: absolute; }
#background-grid { color: #3a3a3a; z-index: 1; }

#grid, #instructions, #background-grid {
    text-align: center;
    /* display: block; */
}

#how {
    width: 500px;
    margin: 200px auto 400px auto;
}
.n { color: #ccc; } .a { color: #D04611; }
</style>

<script>
/* Theoretical stuff. */

const drawLine = (start, end) => {
    let [x0,y0] = start;
    let [x1,y1] = end;
    const dx = Math.abs(x1 - x0);
    const sx = x0 < x1 ? 1 : -1;
    const dy = -Math.abs(y1 - y0);
    const sy = y0 < y1 ? 1 : -1;
    let error = dx + dy;

    const line = [];
    while (true) {
        line.push([x0,y0]);
        if (x0 === x1 && y0 === y1) { break; }
        const e2 = 2 * error;
        if (e2 >= dy) {
            if (x0 === x1) { break; }
            error += dy;
            x0 += sx;
        }

        if (e2 <= dx) {
            if (y0 === y1) { break; }
            error += dx;
            y0 += sy;
        }
    }

    return line;
}


const drawFilledCircle = (radius) => {
    let x = radius;
    let y = 0;
    let error = 3 - 2*radius;
    const points = new Set();
    while (x >= y)
    {
        for (let i = -x; i <= x; i++) {
            for (const j of [y, -y]) {
                points.add(pointToStr([i,j]));
                points.add(pointToStr([j,i]));
            }
        }
        if (error > 0)
        {
            x -= 1;
            error -= 4*x;
        }
        y += 1;
        error += 4*y + 2;
    }

    return points;
}

const pointsEq = (a,b) => a[0] === b[0] && a[1] === b[1];

const addLineToTree = (treeData, i, j, reverse, circlePoints) => {
    let currentIdx = 0;
    const treeArray = treeData.treeArray;
    const backPaths = treeData.backPaths;
    let currentTree = treeArray[0];
    const start = [0,0];
    const end = [i,j];
    let line = reverse
        ? drawLine(end, start).reverse()
        : drawLine(start, end);
    // every line starts with [0,0], remove it
    for (const p of line.slice(1, line.length)) {
        if (!circlePoints.has(pointToStr(p))) {
            break;
        }
        // each entry in treeArray is a list of pairs [i, p] where i is the index and p is the point.
        let childData = currentTree.find(t => pointsEq(t.point, p));
        let child = null;
        let newIdx;
        if (childData === undefined) {
            child = [];
            treeArray.push(child);
            newIdx = treeArray.length-1;
            currentTree.push({index: treeArray.length-1, point: p});
        } else {
            child = treeArray[childData.index];
        }
        currentTree = child;
    }
}

/// Builds a visibility tree. The tree is stored in an array of arrays
/// [childIndices] where point is of the form [x,y] and [childIndices]
/// is a list of array indices to the node's children. tree[0] is the root.
const buildTree = (radius) => {
    const treeData = {
        treeArray: [[]],
        backPaths: new Map(),
    };
    const pointsToDrawLinesTo = [];
    // Open question: How many cells do you have to check to get all
    // possible lines within a given radius? Checking only cells
    // within the circle is definitely not enough. Is a square of
    // side length 2r good enough? Gone with 4r here which is probably
    // overkill, but I don't actually know the answer to this.
    //
    // The best thing to do is probably to try some ridiculously large
    // number and properly pre-calculate the trees rather than
    // do them on page load as I&'m doing here.
    for (let i = -2*radius; i <= 2*radius; i++) {
        for (let j = -2*radius; j <= 2*radius; j++) {
            pointsToDrawLinesTo.push([i,j]);
        }
    }
    const circlePoints = drawFilledCircle(radius);

    for (const [i,j] of pointsToDrawLinesTo) {//Array.from(circlePoints).map(pointFromStr)) {
        // Allow for biasing even splits both ways in the line-drawing
        // algorithm for extra viewability.
        for (const reverse of [false, true]) {
            addLineToTree(treeData, i, j, reverse, circlePoints);
        }
    }

    return treeData;
}

const pointToStr = p => `${p[0]},${p[1]}`;
const pointFromStr = s => s.split(",").map(i => parseInt(i));

const getVisiblePoints = (initialPoint, blocksVisibility, visibilityTree) => {
    const [x,y] = initialPoint;
    const visiblePoints = new Set();
    const treeArray = visibilityTree.treeArray;
    const backPaths = visibilityTree.backPaths;
    const noBackPath = new Set();
    // I hate JavaScript
    const stack = [{point: [0,0], childrenData: treeArray[0]}];
    while (stack.length > 0) {
        const nextTree = stack.pop();
        const [i,j] = nextTree.point;
        const strPoint = pointToStr(nextTree.point);
        const translatedPoint = [x+i,y+j];
        if (!noBackPath.has(strPoint)) {

        }
        backPaths[pointToStr(nextTree.point)] = 

        // if backpath check then
        visiblePoints.add(pointToStr(translatedPoint));
        if (!blocksVisibility(translatedPoint)) {
            stack.push(...nextTree.childrenData.map(t_i => {
                return {point: t_i.point, childrenData: treeArray[t_i.index]};
            }));
        }
    }

    return visiblePoints;
}

// Example-specific things.

const WIDTH = 100;
const HEIGHT = 35;
let CURRENT_RADIUS = 12;
const MIN_RADIUS = 5;
const MAX_RADIUS = 22;
const WALL_LIKELIHOOD = 0.075;

const TREES = [];
for (let i = 0; i < MIN_RADIUS; i++) {
    TREES.push(null);
}
for (let i = MIN_RADIUS; i <= MAX_RADIUS; i++) {
    TREES.push(buildTree(i));
}

const arrContains = (arr, p) => {
    const [i,j] = p;
    if (0 <= j && j < arr.length) {
        const row = arr[j];
        return 0 <= i && i < row.length;
    } else {
        return false;
    }
}

const arrIndex = (arr, p) => {
    const [i,j] = p;
    return arr[j][i];
}

const arrSetIndex = (arr, p, v) => {
    const [i,j] = p;
    arr[j][i] = v;
}


const genWallArray = prob => {
    const arr = [];
    for (let j = 0; j < HEIGHT; j++) {
        const row = [];
        for (let i = 0; i < WIDTH; i++) {
            row.push(Math.random() < prob);
        }
        arr.push(row);
    }
    arrSetIndex(arr, player, false);
    return arr;
}

let player = [Math.floor(WIDTH/2), Math.floor(HEIGHT/2)];
let WALL_ARRAY = genWallArray(WALL_LIKELIHOOD);

const blocksVisibility = point => !arrContains(WALL_ARRAY, point) || arrIndex(WALL_ARRAY, point);

const printArena = (arr, player, sightRadius) => {
    const visiblePoints = getVisiblePoints(player, blocksVisibility, TREES[sightRadius]);
    const chars = [];
    const backgroundChars = [];
    for (let j = 0; j < arr.length; j++) {
        for (let i = 0; i < arr[j].length; i++) {
            const point = [i,j];
            const visible = visiblePoints.has(pointToStr(point));
            const c = !visible ? " "
                : pointsEq(point, player) ? "@"
                : arrIndex(arr, point) ? "#"
                : ".";
            if (c === "@") {
                chars.push(`<span class=\"a\">${c}</span>`);
            } else {
                chars.push(c);
            }
            const backgroundC = visible ? " " : ".";
            backgroundChars.push(backgroundC);
        }
        chars.push("\n");
        backgroundChars.push("\n");
    }

    return [chars.join(""), backgroundChars.join("")];
}

const GRID = document.getElementById("grid");
const BACKGROUND = document.getElementById("background-grid");
[GRID.innerHTML, BACKGROUND.innerHTML] = printArena(WALL_ARRAY, player, CURRENT_RADIUS);
const UP = "UP";
const RIGHT = "RIGHT";
const DOWN = "DOWN";
const LEFT = "LEFT";
const PLACE_UP = "PLACE_UP";
const PLACE_RIGHT = "PLACE_RIGHT";
const PLACE_DOWN = "PLACE_DOWN";
const PLACE_LEFT = "PLACE_LEFT";
const DECREASE_RADIUS = "DECREASE_RADIUS";
const INCREASE_RADIUS = "INCREASE_RADIUS";
const SHUFFLE = "SHUFFLE";
const CLEAR = "CLEAR";
const processKeyboardInput = code => {
    switch (code) {
        case "ArrowUp":    return UP;
        case "ArrowRight": return RIGHT;
        case "ArrowDown":  return DOWN;
        case "ArrowLeft":  return LEFT;
        case "KeyW":       return PLACE_UP;
        case "KeyD":       return PLACE_RIGHT;
        case "KeyS":       return PLACE_DOWN;
        case "KeyX":       return PLACE_DOWN;
        case "KeyA":       return PLACE_LEFT;
        case "KeyQ":       return DECREASE_RADIUS;
        case "KeyE":       return INCREASE_RADIUS;
        case "KeyR":       return SHUFFLE;
        case "KeyC":       return CLEAR;
        default:           return null;
    }
}

const processLogicalInput = input => {
    let changed = false;
    let [i,j] = player;
    let newPosition = undefined;

    if (input === DECREASE_RADIUS || input === INCREASE_RADIUS) {
        if (input === DECREASE_RADIUS) {
            CURRENT_RADIUS = Math.max(CURRENT_RADIUS-1, MIN_RADIUS);
        } else {
            CURRENT_RADIUS = Math.min(CURRENT_RADIUS+1, MAX_RADIUS);
        }
        changed = true;
    } else if (input === SHUFFLE) {
        WALL_ARRAY = genWallArray(WALL_LIKELIHOOD);
        changed = true;
    } else if (input === CLEAR) {
        WALL_ARRAY = genWallArray(0);
        changed = true;
    } else {
        switch (input) {
            case UP:    case PLACE_UP:    newPosition = [i, j-1]; break;
            case RIGHT: case PLACE_RIGHT: newPosition = [i+1, j]; break;
            case DOWN:  case PLACE_DOWN:  newPosition = [i, j+1]; break;
            case LEFT:  case PLACE_LEFT:  newPosition = [i-1, j]; break;
            default: break;
        }
        let moveType = input.startsWith("PLACE") ? "PLACE" : "MOVE";

        if (newPosition !== undefined && arrContains(WALL_ARRAY, newPosition)) {
            if (moveType === "MOVE") {
                // point exists and is a wall
                if (!arrIndex(WALL_ARRAY, newPosition)) {
                    player = newPosition;
                    changed = true;
                }
            } else {
                const isWall = arrIndex(WALL_ARRAY, newPosition);
                arrSetIndex(WALL_ARRAY, newPosition, !isWall);
                changed = true;
            }
        }
    }

    if (changed) {
        [GRID.innerHTML, BACKGROUND.innerHTML] = printArena(WALL_ARRAY, player, CURRENT_RADIUS);
    }
}


document.addEventListener("keydown", e => {
    if (!e.altKey && !e.ctrlKey && !e.shiftKey) {
        const input = processKeyboardInput(e.code);
        if (input !== null) {
            e.preventDefault();
            processLogicalInput(input);
        }
    }
});
</script>